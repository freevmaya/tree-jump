# COMBINED PROJECT FILES FOR DEEPSEEK
# Encoding: UTF-8
# Processed extensions: .js, .html

# ============================================================
# FILE: .\index.html
# TYPE: .HTML
# ============================================================

<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tree Jump ‚Äî –æ—Ç—Å–∫–æ–∫–∏ –æ—Ç –¥–µ—Ä–µ–≤–∞</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      overflow: hidden;
      background: #87CEEB;
      font-family: 'Segoe UI', system-ui, sans-serif;
      cursor: grab;
      user-select: none;
    }
    body:active { cursor: grabbing; }
    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    canvas { display: block; outline: none; }
    .hint {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(0,0,0,0.6);
      background: rgba(255,255,240,0.25);
      backdrop-filter: blur(4px);
      padding: 8px 18px;
      border-radius: 40px;
      font-size: 15px;
      font-weight: 500;
      pointer-events: none;
      text-shadow: 0 1px 2px rgba(255,255,255,0.3);
      border: 1px solid rgba(255,255,255,0.3);
      white-space: nowrap;
      z-index: 100;
    }
    .bounce-indicator {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0,0,0,0.3);
      backdrop-filter: blur(4px);
      color: white;
      padding: 6px 14px;
      border-radius: 30px;
      font-size: 14px;
      font-weight: 500;
      border: 1px solid rgba(255,255,255,0.2);
      pointer-events: none;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div class="hint">üñ±Ô∏è –ó–∞–∂–º–∏—Ç–µ –ª–µ–≤—É—é –∫–Ω–æ–ø–∫—É –∏ —Ç—è–Ω–∏—Ç–µ, —á—Ç–æ–±—ã –≤—Ä–∞—â–∞—Ç—å –¥–µ—Ä–µ–≤–æ</div>
  <div class="bounce-indicator" id="bounce-counter">üî• –û—Ç—Å–∫–æ–∫–æ–≤: 0</div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "@scripts/": "./scripts/"
    }
  }
  </script>
  <script type="module" src="./scripts/main.js"></script>
</body>
</html>


# ============================================================
# FILE: .\scripts\GameState.js
# TYPE: .JS
# ============================================================

// scripts/GameState.js

export const GAME_STATE = {
  PLAYING: 'playing',
  GAME_OVER: 'gameOver'
};

export class GameState {
  constructor() {
    this.state = GAME_STATE.PLAYING;
    this.gameOverCallbacks = [];
    this.resetCallbacks = [];
  }
  
  isPlaying() {
    return this.state === GAME_STATE.PLAYING;
  }
  
  isGameOver() {
    return this.state === GAME_STATE.GAME_OVER;
  }
  
  gameOver() {
    if (this.state !== GAME_STATE.GAME_OVER) {
      this.state = GAME_STATE.GAME_OVER;
      this.gameOverCallbacks.forEach(callback => callback());
    }
  }
  
  reset() {
    this.state = GAME_STATE.PLAYING;
    this.resetCallbacks.forEach(callback => callback());
  }
  
  onGameOver(callback) {
    this.gameOverCallbacks.push(callback);
  }
  
  onReset(callback) {
    this.resetCallbacks.push(callback);
  }
}


# ============================================================
# FILE: .\scripts\constants.js
# TYPE: .JS
# ============================================================

// scripts/constants.js

// ========== –ö–û–ù–°–¢–ê–ù–¢–´ ==========
// –î–µ—Ä–µ–≤–æ
export const TREE_COLOR = 0xA67C52;
export const TREE_HEIGHT = 70;
export const TEXTURE_SCALE_Y = 1.5;
export const MAIN_RADIUS = 1;
export const MAIN_DIAMETER = MAIN_RADIUS * 2;

// –í—ã—Å—Ç—É–ø—ã –∏ –ø–ª–æ—â–∞–¥–∫–∏ –Ω–∞ –¥–µ—Ä–µ–≤–µ
export const STICK_OUT = 0.1 * MAIN_DIAMETER;
export const PLATFORM_RADIUS = MAIN_DIAMETER * 0.4 / 2;
export const PLATFORM_HEIGHT = 0.02 * MAIN_DIAMETER;
export const CYLINDER_HALF_HEIGHT = TREE_HEIGHT / 2;
export const PLATFORM_DENSITY = 0.5;
export const PLATFORM_COUNT = Math.floor(TREE_HEIGHT * PLATFORM_DENSITY);

// –ë–∞–∑–æ–≤–∞—è –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞
export const BASE_PLATFORM_SIZE = 20;
export const BASE_PLATFORM_TOP_Y = -2.8 + 0.075;

// –®–∞—Ä–∏–∫
export const BALL_RADIUS = 0.15;

// –§–∏–∑–∏–∫–∞ —à–∞—Ä–∏–∫–∞
export const GRAVITY = -9.8;
export const BOUNCE_SPEED = 7.5;
export const MAX_VELOCITY = 15;

// –ö–∞–º–µ—Ä–∞
export const CAMERA_FOLLOW_SPEED = 0.06;
export const CAMERA_HEIGHT_OFFSET = 2.8;
export const CAMERA_START_Y = 0;

// –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º—ã—à—å—é
export const ROTATION_SPEED = 0.005;
export const INERTIA = 0.92;

// –¶–≤–µ—Ç–∞
export const FLOOR_COLOR = 0x1e1b2e;
export const BASE_PLATFORM_COLOR = 0x4a5568;
export const BALL_COLOR = 0xff6b6b;
export const AMBIENT_LIGHT_COLOR = 0x404080;
export const KEY_LIGHT_COLOR = 0xffffff;
export const FILL_LIGHT_COLOR = 0x6366f1;
export const RIM_LIGHT_COLOR = 0x818cf8;
export const WIREFRAME_COLOR = 0xC4956A;

// –°–≤–µ—Ç
export const AMBIENT_LIGHT_INTENSITY = 0.5;
export const KEY_LIGHT_INTENSITY = 1.2;
export const FILL_LIGHT_INTENSITY = 0.4;
export const RIM_LIGHT_INTENSITY = 0.6;
export const RIM_LIGHT_DISTANCE = 12;

// –ü—É—Ç–∏ –∫ —Ç–µ–∫—Å—Ç—É—Ä–∞–º
export const BARK_TEXTURE_PATH = 'textures/bark.jpg';

// –ò–≥—Ä–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
export const GAME_OVER_Y_OFFSET = -5; // –°–º–µ—â–µ–Ω–∏–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫–∞–º–µ—Ä—ã –¥–ª—è –∫–æ–Ω—Ü–∞ –∏–≥—Ä—ã
export const RESET_POSITION_X = 0;
export const RESET_POSITION_Z = MAIN_RADIUS * 1.3;
export const RESET_POSITION_Y = BASE_PLATFORM_TOP_Y + BALL_RADIUS;
export const RESET_VELOCITY_Y = BOUNCE_SPEED;


# ============================================================
# FILE: .\scripts\controls\MouseRotationControl.js
# TYPE: .JS
# ============================================================

// scripts/controls/MouseRotationControl.js
import { ROTATION_SPEED, INERTIA } from '../constants.js';

export class MouseRotationControl {
  constructor(tree, container) {
    this.tree = tree;
    this.container = container;
    this.isDragging = false;
    this.previousMouseX = 0;
    this.velocityY = 0;
    this.rotationSpeed = ROTATION_SPEED;
    this.inertia = INERTIA;
    
    this.onMouseDown = this.onMouseDown.bind(this);
    this.onMouseMove = this.onMouseMove.bind(this);
    this.onMouseUp = this.onMouseUp.bind(this);
    this.onMouseLeave = this.onMouseUp.bind(this);
  }
  
  init() {
    this.container.addEventListener('mousedown', this.onMouseDown);
    window.addEventListener('mousemove', this.onMouseMove);
    window.addEventListener('mouseup', this.onMouseUp);
    window.addEventListener('mouseleave', this.onMouseLeave);
  }
  
  destroy() {
    this.container.removeEventListener('mousedown', this.onMouseDown);
    window.removeEventListener('mousemove', this.onMouseMove);
    window.removeEventListener('mouseup', this.onMouseUp);
    window.removeEventListener('mouseleave', this.onMouseLeave);
  }
  
  onMouseDown(e) {
    this.isDragging = true;
    this.previousMouseX = e.clientX;
    this.velocityY = 0;
  }
  
  onMouseMove(e) {
    if (!this.isDragging) return;
    const dx = e.clientX - this.previousMouseX;
    this.velocityY = dx * this.rotationSpeed;
    this.tree.rotate(this.velocityY);
    this.previousMouseX = e.clientX;
  }
  
  onMouseUp() {
    this.isDragging = false;
  }
  
  update() {
    if (!this.isDragging) {
      this.velocityY *= this.inertia;
      if (Math.abs(this.velocityY) > 0.0001) {
        this.tree.rotate(this.velocityY);
      }
    }
  }
  
  reset() {
    this.isDragging = false;
    this.velocityY = 0;
  }
}


# ============================================================
# FILE: .\scripts\core\CameraController.js
# TYPE: .JS
# ============================================================

// scripts/core/CameraController.js
import * as THREE from 'three';
import { CAMERA_FOLLOW_SPEED, CAMERA_HEIGHT_OFFSET, CAMERA_START_Y } from '../constants.js';

export class CameraController {
  constructor(aspectRatio) {
    this.camera = new THREE.PerspectiveCamera(50, aspectRatio, 0.1, 100);
    this.camera.position.set(2, CAMERA_START_Y, 9);
    this.targetY = 0;
    this.followSpeed = CAMERA_FOLLOW_SPEED;
    this.heightOffset = CAMERA_HEIGHT_OFFSET;
  }
  
  update(targetY) {
    this.targetY = targetY + this.heightOffset;
    this.camera.position.y += (this.targetY - this.camera.position.y) * this.followSpeed;
    this.camera.lookAt(0, this.camera.position.y, 0);
  }
  
  setPosition(x, y, z) {
    this.camera.position.set(x, y, z);
  }
  
  getCamera() {
    return this.camera;
  }
  
  resize(aspectRatio) {
    this.camera.aspect = aspectRatio;
    this.camera.updateProjectionMatrix();
  }
}


# ============================================================
# FILE: .\scripts\core\RendererManager.js
# TYPE: .JS
# ============================================================

// scripts/core/RendererManager.js
import * as THREE from 'three';

export class RendererManager {
  constructor(container) {
    this.container = container;
    this.renderer = null;
    this.width = container.clientWidth;
    this.height = container.clientHeight;
  }
  
  init() {
    this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    this.renderer.setSize(this.width, this.height);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
    this.renderer.toneMappingExposure = 1.0;
    this.renderer.outputColorSpace = THREE.SRGBColorSpace;
    
    this.container.appendChild(this.renderer.domElement);
    return this.renderer;
  }
  
  resize() {
    this.width = this.container.clientWidth;
    this.height = this.container.clientHeight;
    this.renderer.setSize(this.width, this.height);
  }
  
  render(scene, camera) {
    this.renderer.render(scene, camera);
  }
  
  getRenderer() {
    return this.renderer;
  }
  
  getAspectRatio() {
    return this.width / this.height;
  }
}


# ============================================================
# FILE: .\scripts\core\SceneManager.js
# TYPE: .JS
# ============================================================

// scripts/core/SceneManager.js
import * as THREE from 'three';

export class SceneManager {
  constructor() {
    this.scene = null;
    this.fogColor = 0xB0E0E6;
    this.backgroundColor = 0x87CEEB;
  }
  
  init() {
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(this.backgroundColor);
    this.scene.fog = new THREE.Fog(this.fogColor, 12, 28);
    return this.scene;
  }
  
  getScene() {
    return this.scene;
  }
  
  add(object) {
    this.scene.add(object);
  }
  
  remove(object) {
    this.scene.remove(object);
  }
}


# ============================================================
# FILE: .\scripts\main.js
# TYPE: .JS
# ============================================================

// scripts/main.js
import * as THREE from 'three';
import { 
  GRAVITY, BASE_PLATFORM_SIZE, BASE_PLATFORM_COLOR,
  FLOOR_COLOR, AMBIENT_LIGHT_COLOR, AMBIENT_LIGHT_INTENSITY,
  KEY_LIGHT_COLOR, KEY_LIGHT_INTENSITY, FILL_LIGHT_COLOR,
  FILL_LIGHT_INTENSITY, RIM_LIGHT_COLOR, RIM_LIGHT_INTENSITY,
  RIM_LIGHT_DISTANCE, TREE_HEIGHT, MAIN_RADIUS,
  GAME_OVER_Y_OFFSET, RESET_POSITION_X, RESET_POSITION_Y,
  RESET_POSITION_Z, RESET_VELOCITY_Y, CAMERA_START_Y
} from './constants.js';

import { SceneManager } from './core/SceneManager.js';
import { RendererManager } from './core/RendererManager.js';
import { CameraController } from './core/CameraController.js';
import { Tree } from './models/Tree.js';
import { Ball } from './models/Ball.js';
import { BallPhysics } from './physics/BallPhysics.js';
import { MouseRotationControl } from './controls/MouseRotationControl.js';
import { GameState, GAME_STATE } from './GameState.js';

class Game {
  constructor() {
    this.container = document.getElementById('canvas-container');
    this.sceneManager = new SceneManager();
    this.rendererManager = new RendererManager(this.container);
    this.cameraController = null;
    this.tree = null;
    this.ball = null;
    this.physics = null;
    this.mouseControl = null;
    this.bounceCounterElement = document.getElementById('bounce-counter');
    this.lastTime = performance.now();
    this.gameState = new GameState();
    
    // –•—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –æ–∫—Ä—É–∂–µ–Ω–∏—è
    this.environmentObjects = [];
    this.lights = [];
    
    // –°–æ–∑–¥–∞–Ω–∏–µ UI –¥–ª—è –∫–æ–Ω—Ü–∞ –∏–≥—Ä—ã
    this.createGameOverUI();
  }
  
  createGameOverUI() {
    // –°–æ–∑–¥–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∫–æ–Ω—Ü–∞ –∏–≥—Ä—ã
    this.gameOverElement = document.createElement('div');
    this.gameOverElement.style.position = 'fixed';
    this.gameOverElement.style.top = '50%';
    this.gameOverElement.style.left = '50%';
    this.gameOverElement.style.transform = 'translate(-50%, -50%)';
    this.gameOverElement.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    this.gameOverElement.style.color = 'white';
    this.gameOverElement.style.padding = '30px 50px';
    this.gameOverElement.style.borderRadius = '20px';
    this.gameOverElement.style.fontSize = '32px';
    this.gameOverElement.style.fontWeight = 'bold';
    this.gameOverElement.style.textAlign = 'center';
    this.gameOverElement.style.zIndex = '200';
    this.gameOverElement.style.backdropFilter = 'blur(5px)';
    this.gameOverElement.style.border = '2px solid rgba(255, 255, 255, 0.3)';
    this.gameOverElement.style.boxShadow = '0 10px 30px rgba(0, 0, 0, 0.5)';
    this.gameOverElement.style.display = 'none';
    this.gameOverElement.innerHTML = `
      <div>üíÄ –ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê üíÄ</div>
      <div style="font-size: 18px; margin-top: 20px; color: #ff6b6b;">–ù–∞–∂–º–∏—Ç–µ R –¥–ª—è –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞</div>
    `;
    document.body.appendChild(this.gameOverElement);
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –∫–ª–∞–≤–∏—à–∏ R –¥–ª—è –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞
    window.addEventListener('keydown', (e) => {
      if (e.key === 'r' || e.key === 'R') {
        this.resetGame();
      }
    });
    
    // –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ —Å–æ–±—ã—Ç–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã
    this.gameState.onGameOver(() => {
      this.gameOverElement.style.display = 'block';
      this.mouseControl.destroy(); // –û—Ç–∫–ª—é—á–∞–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∏ –æ–∫–æ–Ω—á–∞–Ω–∏–∏ –∏–≥—Ä—ã
    });
    
    this.gameState.onReset(() => {
      this.gameOverElement.style.display = 'none';
    });
  }
  
  clearEnvironment() {
    // –£–¥–∞–ª—è–µ–º –≤—Å–µ –æ–±—ä–µ–∫—Ç—ã –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–∑ —Å—Ü–µ–Ω—ã
    const scene = this.sceneManager.getScene();
    
    this.environmentObjects.forEach(obj => {
      if (obj.parent) {
        scene.remove(obj);
      }
    });
    this.environmentObjects = [];
    
    // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä–æ–µ –¥–µ—Ä–µ–≤–æ
    if (this.tree && this.tree.mesh) {
      scene.remove(this.tree.mesh);
      this.tree = null;
    }
    
    // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π —à–∞—Ä–∏–∫
    if (this.ball && this.ball.mesh) {
      scene.remove(this.ball.mesh);
      this.ball = null;
    }
    
    // –û—Å–≤–µ—â–µ–Ω–∏–µ –Ω–µ —É–¥–∞–ª—è–µ–º, –æ–Ω–æ –æ—Å—Ç–∞–µ—Ç—Å—è
  }
  
  init() {
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ü–µ–Ω—ã
    const scene = this.sceneManager.init();
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–Ω–¥–µ—Ä–µ—Ä–∞
    this.rendererManager.init();
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞–º–µ—Ä—ã
    this.cameraController = new CameraController(this.rendererManager.getAspectRatio());
    
    // –°–æ–∑–¥–∞–Ω–∏–µ –æ—Å–≤–µ—â–µ–Ω–∏—è (—Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑)
    this.createLights(scene);
    
    // –°–æ–∑–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–≤—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
    this.createGameObjects();
    
    // –ó–∞–ø—É—Å–∫ –∞–Ω–∏–º–∞—Ü–∏–∏
    this.animate();
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
    window.addEventListener('resize', this.onResize.bind(this));
  }
  
  createGameObjects() {
    const scene = this.sceneManager.getScene();
    
    // –°–æ–∑–¥–∞–Ω–∏–µ –¥–µ—Ä–µ–≤–∞
    this.tree = new Tree(scene);
    this.tree.init();
    
    // –°–æ–∑–¥–∞–Ω–∏–µ —à–∞—Ä–∏–∫–∞
    this.ball = new Ball(scene);
    this.ball.init();
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ñ–∏–∑–∏–∫–∏
    this.physics = new BallPhysics(this.ball, this.tree);
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º—ã—à—å—é
    if (this.mouseControl) {
      this.mouseControl.destroy();
    }
    this.mouseControl = new MouseRotationControl(this.tree, this.container);
    this.mouseControl.init();
    
    // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª–∞ –∏ –±–∞–∑–æ–≤–æ–π –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
    this.createEnvironment(scene);
  }
  
  resetGame() {
    // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä–æ–µ –æ–∫—Ä—É–∂–µ–Ω–∏–µ
    this.clearEnvironment();
    
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ –∏–≥—Ä–æ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã —Å –Ω–æ–≤—ã–º–∏ —Å–ª—É—á–∞–π–Ω—ã–º–∏ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞–º–∏
    this.createGameObjects();
    
    // –°–±—Ä–æ—Å –∫–∞–º–µ—Ä—ã
    this.cameraController.setPosition(2, CAMERA_START_Y, 9);
    
    // –°–±—Ä–æ—Å —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã
    this.gameState.reset();
    
    // –í–∫–ª—é—á–∞–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω–æ
    this.mouseControl.init();
  }
  
  createLights(scene) {
    // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ —Å–≤–µ—Ç–∞
    this.lights.forEach(light => {
      if (light.parent) {
        scene.remove(light);
      }
    });
    this.lights = [];
    
    const ambient = new THREE.AmbientLight(AMBIENT_LIGHT_COLOR, AMBIENT_LIGHT_INTENSITY);
    scene.add(ambient);
    this.lights.push(ambient);
    
    const keyLight = new THREE.DirectionalLight(KEY_LIGHT_COLOR, KEY_LIGHT_INTENSITY);
    keyLight.position.set(4, 6, 5);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.set(1024, 1024);
    keyLight.shadow.camera.near = 0.5;
    keyLight.shadow.camera.far = 20;
    keyLight.shadow.camera.left = -5;
    keyLight.shadow.camera.right = 5;
    keyLight.shadow.camera.top = 5;
    keyLight.shadow.camera.bottom = -5;
    keyLight.shadow.bias = -0.0001;
    scene.add(keyLight);
    this.lights.push(keyLight);
    
    const fillLight = new THREE.DirectionalLight(FILL_LIGHT_COLOR, FILL_LIGHT_INTENSITY);
    fillLight.position.set(-3, 2, 3);
    scene.add(fillLight);
    this.lights.push(fillLight);
    
    const rimLight = new THREE.PointLight(RIM_LIGHT_COLOR, RIM_LIGHT_INTENSITY, RIM_LIGHT_DISTANCE);
    rimLight.position.set(-2, -1, 4);
    scene.add(rimLight);
    this.lights.push(rimLight);
  }
  
  createEnvironment(scene) {
    // –ü–æ–ª
    const floorGeometry = new THREE.CircleGeometry(6, 64);
    const floorMaterial = new THREE.MeshStandardMaterial({
      color: FLOOR_COLOR,
      metalness: 0.1,
      roughness: 0.8,
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -TREE_HEIGHT / 2 - 0.01;
    floor.receiveShadow = true;
    scene.add(floor);
    this.environmentObjects.push(floor);
    
    // –ë–∞–∑–æ–≤–∞—è –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞
    const basePlatformGeometry = new THREE.BoxGeometry(BASE_PLATFORM_SIZE, 0.15, BASE_PLATFORM_SIZE);
    const basePlatformMaterial = new THREE.MeshStandardMaterial({
      color: BASE_PLATFORM_COLOR,
      metalness: 0.1,
      roughness: 0.85,
    });
    const basePlatform = new THREE.Mesh(basePlatformGeometry, basePlatformMaterial);
    basePlatform.position.set(0, -2.8, 0);
    basePlatform.receiveShadow = true;
    basePlatform.castShadow = true;
    scene.add(basePlatform);
    this.environmentObjects.push(basePlatform);
  }
  
  onResize() {
    this.rendererManager.resize();
    this.cameraController.resize(this.rendererManager.getAspectRatio());
  }
  
  updateBounceCounter() {
    if (this.bounceCounterElement && this.ball) {
      this.bounceCounterElement.textContent = `üî• –û—Ç—Å–∫–æ–∫–æ–≤: ${this.ball.getBounceCount()}`;
    }
  }
  
  checkGameOver() {
    if (!this.gameState.isPlaying() || !this.ball) return;
    
    const ballPos = this.ball.getPosition();
    const cameraY = this.cameraController.getCamera().position.y;
    
    // –ï—Å–ª–∏ —à–∞—Ä–∏–∫ —É–ø–∞–ª –Ω–∏–∂–µ –∫–∞–º–µ—Ä—ã –Ω–∞ –∑–∞–¥–∞–Ω–Ω–æ–µ —Å–º–µ—â–µ–Ω–∏–µ
    if (ballPos.y < cameraY + GAME_OVER_Y_OFFSET) {
      this.gameState.gameOver();
    }
  }
  
  animate() {
    requestAnimationFrame(this.animate.bind(this));
    
    const time = performance.now();
    const dt = (time - this.lastTime) / 1000;
    this.lastTime = time;
    
    if (this.gameState.isPlaying() && this.ball && this.physics) {
      // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ñ–∏–∑–∏–∫–∏ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∏–≥—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞
      this.physics.update(dt);
      
      // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–∞—â–µ–Ω–∏—è –º—ã—à–∏
      if (this.mouseControl) {
        this.mouseControl.update();
      }
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ü–∞ –∏–≥—Ä—ã
      this.checkGameOver();
    }
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã (–≤—Å–µ–≥–¥–∞, —á—Ç–æ–±—ã –∫–∞–º–µ—Ä–∞ –Ω–µ —É–ª–µ—Ç–∞–ª–∞)
    if (this.ball) {
      this.cameraController.update(this.ball.getLastBounceY());
    }
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—á–µ—Ç—á–∏–∫–∞ –æ—Ç—Å–∫–æ–∫–æ–≤
    this.updateBounceCounter();
    
    // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥
    if (this.sceneManager.getScene() && this.cameraController) {
      this.rendererManager.render(this.sceneManager.getScene(), this.cameraController.getCamera());
    }
  }
}

// –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
document.addEventListener('DOMContentLoaded', () => {
  const game = new Game();
  game.init();
});


# ============================================================
# FILE: .\scripts\models\Ball.js
# TYPE: .JS
# ============================================================

// scripts/models/Ball.js
import * as THREE from 'three';
import { BALL_RADIUS, BALL_COLOR, BASE_PLATFORM_TOP_Y, BOUNCE_SPEED, MAIN_RADIUS } from '../constants.js';

export class Ball {
  constructor(scene) {
    this.scene = scene;
    this.mesh = null;
    this.velocity = new THREE.Vector3(0, BOUNCE_SPEED, 0);
    this.lastBounceY = BASE_PLATFORM_TOP_Y;
    this.bounceCount = 0;
  }
  
  init() {
    const geometry = new THREE.SphereGeometry(BALL_RADIUS, 16, 16);
    const material = new THREE.MeshStandardMaterial({
      color: BALL_COLOR,
      metalness: 0.3,
      roughness: 0.4,
    });
    
    this.mesh = new THREE.Mesh(geometry, material);
    this.mesh.position.set(0, BASE_PLATFORM_TOP_Y + BALL_RADIUS, MAIN_RADIUS * 1.3);
    this.mesh.castShadow = true;
    this.mesh.receiveShadow = true;
    
    this.scene.add(this.mesh);
    return this.mesh;
  }
  
  setPosition(x, y, z) {
    this.mesh.position.set(x, y, z);
  }
  
  getPosition() {
    return this.mesh.position.clone();
  }
  
  getWorldPosition() {
    const pos = new THREE.Vector3();
    this.mesh.getWorldPosition(pos);
    return pos;
  }
  
  setVelocity(y) {
    this.velocity.y = y;
  }
  
  getVelocity() {
    return this.velocity.clone();
  }
  
  applyGravity(dt, gravity) {
    this.velocity.y += gravity * dt;
  }
  
  limitVelocity(maxVelocity) {
    this.velocity.y = Math.max(-maxVelocity, Math.min(maxVelocity, this.velocity.y));
  }
  
  updatePosition(dt) {
    this.mesh.position.add(this.velocity.clone().multiplyScalar(dt));
  }
  
  bounce(bounceY, bounceSpeed) {
    this.mesh.position.y = bounceY + BALL_RADIUS * Math.sign(bounceSpeed);
    this.velocity.y = bounceSpeed;
    this.lastBounceY = bounceY;
    this.bounceCount++;
    return this.bounceCount;
  }
  
  getLastBounceY() {
    return this.lastBounceY;
  }
  
  getBounceCount() {
    return this.bounceCount;
  }
  
  resetBounceCount() {
    this.bounceCount = 0;
  }
}


# ============================================================
# FILE: .\scripts\models\Platform.js
# TYPE: .JS
# ============================================================

// scripts/models/Platform.js
import * as THREE from 'three';
import { 
  TREE_COLOR, STICK_OUT, PLATFORM_RADIUS, PLATFORM_HEIGHT, MAIN_RADIUS
} from '../constants.js';

export class Platform {
  constructor(parentMesh, theta, y) {
    this.parentMesh = parentMesh;
    this.theta = theta;
    this.y = y;
    this.group = null;
    this.box = null;
    this.platformMesh = null;
    
    const boxWidth = STICK_OUT * 3;
    const boxHeight = STICK_OUT * 0.6;
    const boxDepth = STICK_OUT * 0.6;
    
    this.boxGeometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
    this.platformGeometry = new THREE.CylinderGeometry(PLATFORM_RADIUS, PLATFORM_RADIUS, PLATFORM_HEIGHT, 16);
    
    this.material = new THREE.MeshStandardMaterial({
      color: TREE_COLOR,
      metalness: 0.0,
      roughness: 0.9,
    });
  }
  
  create() {
    this.group = new THREE.Group();
    this.group.position.set(MAIN_RADIUS * Math.cos(this.theta), this.y, MAIN_RADIUS * Math.sin(this.theta));
    this.group.rotation.y = -this.theta;
    
    // –°–æ–∑–¥–∞–Ω–∏–µ –≤—ã—Å—Ç—É–ø–∞ (–±–æ–∫—Å–∞)
    this.box = new THREE.Mesh(this.boxGeometry, this.material);
    this.box.position.set(-PLATFORM_RADIUS, 0, 0);
    this.box.castShadow = true;
    this.group.add(this.box);
    
    // –°–æ–∑–¥–∞–Ω–∏–µ –ø–ª–æ—â–∞–¥–∫–∏
    this.platformMesh = new THREE.Mesh(this.platformGeometry, this.material);
    this.platformMesh.position.set(STICK_OUT, 0, 0);
    this.platformMesh.castShadow = true;
    this.group.add(this.platformMesh);
    
    this.parentMesh.add(this.group);
    
    return {
      mesh: this.platformMesh,
      group: this.group,
      localY: this.y
    };
  }
  
  updateTexture(texture) {
    if (texture) {
      this.material.map = texture;
      this.material.color.setHex(0xffffff);
      this.material.needsUpdate = true;
    }
  }
}


# ============================================================
# FILE: .\scripts\models\Tree.js
# TYPE: .JS
# ============================================================

// scripts/models/Tree.js
import * as THREE from 'three';
import { 
  TREE_COLOR, TREE_HEIGHT, MAIN_RADIUS, STICK_OUT, 
  PLATFORM_RADIUS, PLATFORM_HEIGHT, PLATFORM_COUNT,
  CYLINDER_HALF_HEIGHT, WIREFRAME_COLOR, BARK_TEXTURE_PATH
} from '../constants.js';
import { Platform } from './Platform.js';

export class Tree {
  constructor(scene) {
    this.scene = scene;
    this.mesh = null;
    this.platforms = [];
    this.textureLoader = new THREE.TextureLoader();
    this.barkTexture = null;
  }
  
  init() {
    // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–≤–æ–ª–∞
    const cylinderGeometry = new THREE.CylinderGeometry(MAIN_RADIUS * 0.5, MAIN_RADIUS, TREE_HEIGHT, 32);
    const cylinderMaterial = new THREE.MeshStandardMaterial({
      color: TREE_COLOR,
      metalness: 0.0,
      roughness: 0.9,
      envMapIntensity: 0,
    });
    
    this.mesh = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
    this.mesh.castShadow = true;
    this.mesh.receiveShadow = true;
    this.mesh.position.set(0, 0, 0);
    
    // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–æ–¥—Å–≤–µ—Ç–∫–∏ –≥—Ä–∞–Ω–µ–π
    this.addWireframe(cylinderGeometry);
    
    // –ó–∞–≥—Ä—É–∑–∫–∞ —Ç–µ–∫—Å—Ç—É—Ä—ã
    this.loadTexture(cylinderMaterial);
    
    // –°–æ–∑–¥–∞–Ω–∏–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º
    this.createPlatforms();
    
    this.scene.add(this.mesh);
    return this.mesh;
  }
  
  addWireframe(geometry) {
    const wireGeometry = new THREE.EdgesGeometry(geometry, 15);
    const wireMaterial = new THREE.LineBasicMaterial({
      color: WIREFRAME_COLOR,
      transparent: true,
      opacity: 0.35,
    });
    const wireframe = new THREE.LineSegments(wireGeometry, wireMaterial);
    this.mesh.add(wireframe);
  }
  
  loadTexture(material) {
    this.textureLoader.load(
      BARK_TEXTURE_PATH,
      (tex) => {
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(2, TREE_HEIGHT / 1.5);
        material.map = tex;
        material.color.setHex(0xffffff);
        material.needsUpdate = true;
      },
      undefined,
      () => console.warn('–¢–µ–∫—Å—Ç—É—Ä–∞ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞: ' + BARK_TEXTURE_PATH)
    );
  }
  
  createPlatforms() {
    // –û—á–∏—â–∞–µ–º –º–∞—Å—Å–∏–≤ –ø–ª–∞—Ç—Ñ–æ—Ä–º –ø–µ—Ä–µ–¥ —Å–æ–∑–¥–∞–Ω–∏–µ–º –Ω–æ–≤—ã—Ö
    this.platforms = [];
    
    for (let i = 0; i < PLATFORM_COUNT; i++) {
      const theta = Math.random() * Math.PI * 2;
      const y = (i / PLATFORM_COUNT * 2 - 1) * CYLINDER_HALF_HEIGHT;
      
      const platform = new Platform(this.mesh, theta, y);
      const platformData = platform.create();
      this.platforms.push(platformData);
    }
  }
  
  getPlatforms() {
    return this.platforms;
  }
  
  rotate(yDelta) {
    if (this.mesh) {
      this.mesh.rotation.y += yDelta;
    }
  }
  
  setRotation(y) {
    if (this.mesh) {
      this.mesh.rotation.y = y;
    }
  }
  
  getRotationY() {
    return this.mesh ? this.mesh.rotation.y : 0;
  }
}


# ============================================================
# FILE: .\scripts\physics\BallPhysics.js
# TYPE: .JS
# ============================================================

// scripts/physics/BallPhysics.js
import * as THREE from 'three';
import { 
  BALL_RADIUS, PLATFORM_RADIUS, PLATFORM_HEIGHT, 
  BASE_PLATFORM_TOP_Y, GRAVITY, BOUNCE_SPEED, MAX_VELOCITY,
  MAIN_RADIUS
} from '../constants.js';

export class BallPhysics {
  constructor(ball, tree) {
    this.ball = ball;
    this.tree = tree;
    this.gravity = GRAVITY;
    this.bounceSpeed = BOUNCE_SPEED;
    this.maxVelocity = MAX_VELOCITY;
    this.baseBounceY = BASE_PLATFORM_TOP_Y;
  }
  
  update(dt) {
    // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–∏
    this.ball.applyGravity(dt, this.gravity);
    this.ball.limitVelocity(this.maxVelocity);
    this.ball.updatePosition(dt);
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å –±–∞–∑–æ–≤–æ–π –ø–ª–∞—Ç—Ñ–æ—Ä–º–æ–π
    this.checkBasePlatformCollision();
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞–º–∏ –Ω–∞ –¥–µ—Ä–µ–≤–µ
    this.checkTreePlatformsCollision();
  }
  
  checkBasePlatformCollision() {
    const ballPos = this.ball.getPosition();
    if (ballPos.y - BALL_RADIUS <= this.baseBounceY) {
      this.ball.bounce(this.baseBounceY, this.bounceSpeed);
    }
  }
  
  checkTreePlatformsCollision() {
    const ballPos = this.ball.getPosition();
    const platforms = this.tree.getPlatforms();
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–∏—Ä–æ–≤–æ–π –º–∞—Ç—Ä–∏—Ü—ã –¥–µ—Ä–µ–≤–∞
    this.tree.mesh.updateMatrixWorld(true);
    
    for (const platformData of platforms) {
      const worldPos = new THREE.Vector3();
      platformData.mesh.getWorldPosition(worldPos);
      const platformWorldY = worldPos.y;
      const platformTop = platformWorldY + PLATFORM_HEIGHT / 2;
      const platformBottom = platformWorldY - PLATFORM_HEIGHT / 2;
      
      const dx = ballPos.x - worldPos.x;
      const dz = ballPos.z - worldPos.z;
      const distance2D = Math.sqrt(dx * dx + dz * dz);
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–≥–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è
      if (distance2D < PLATFORM_RADIUS + BALL_RADIUS) {
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å –í–ï–†–•–ù–ï–ô –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å—é –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
        if (ballPos.y - BALL_RADIUS <= platformTop && 
            ballPos.y + BALL_RADIUS >= platformTop &&
            ballPos.y > platformTop &&
            this.ball.velocity.y < 0) {
          
          // –û—Ç—Å–∫–æ–∫ –æ—Ç –≤–µ—Ä—Ö–Ω–µ–π –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ (–ª–µ—Ç–∏–º –≤–≤–µ—Ä—Ö)
          this.ball.bounce(platformTop, this.bounceSpeed);
          break;
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å –ù–ò–ñ–ù–ï–ô –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å—é –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
        if (ballPos.y + BALL_RADIUS >= platformBottom && 
            ballPos.y - BALL_RADIUS <= platformBottom &&
            ballPos.y < platformBottom &&
            this.ball.velocity.y > 0) {
          
          // –û—Ç—Å–∫–æ–∫ –æ—Ç –Ω–∏–∂–Ω–µ–π –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ - –ª–µ—Ç–∏–º –í–ù–ò–ó (–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å)
          this.ball.bounce(platformBottom, -this.bounceSpeed);
          break;
        }
      }
    }
  }
  
  setGravity(gravity) {
    this.gravity = gravity;
  }
  
  setBounceSpeed(speed) {
    this.bounceSpeed = speed;
  }
}


# ============================================================
# FILE: .\scripts\utils\MathUtils.js
# TYPE: .JS
# ============================================================

// scripts/utils/MathUtils.js

export class MathUtils {
  static clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  
  static lerp(start, end, amount) {
    return start + (end - start) * amount;
  }
  
  static randomRange(min, max) {
    return Math.random() * (max - min) + min;
  }
  
  static degreesToRadians(degrees) {
    return degrees * Math.PI / 180;
  }
  
  static radiansToDegrees(radians) {
    return radians * 180 / Math.PI;
  }
}


